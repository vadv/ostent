// Generated by CoffeeScript 1.7.1
(function() {
  this.newwebsocket = function(onmessage) {
    var conn, init, sendClient, sendJSON, sendSearch;
    conn = null;
    sendSearch = function(search) {
      return sendJSON({
        Search: search
      });
    };
    sendClient = function(client) {
      console.log(JSON.stringify(client), 'sendClient');
      return sendJSON({
        Client: client
      });
    };
    sendJSON = function(obj) {
      if ((conn == null) || conn.readyState === conn.CLOSING || conn.readyState === conn.CLOSED) {
        init();
      }
      if ((conn == null) || conn.readyState !== conn.OPEN) {
        console.log('Not connected, cannot send', obj);
        return;
      }
      return conn.send(JSON.stringify(obj));
    };
    init = function() {
      var again, hostport, statesel;
      hostport = window.location.hostname + (location.port ? ':' + location.port : '');
      conn = new WebSocket('ws://' + hostport + '/ws');
      conn.onopen = function() {
        sendSearch(location.Search);
        $(window).bind('popstate', (function() {
          sendSearch(location.search);
        }));
      };
      statesel = 'table thead tr .header a.state';
      again = function(e) {
        $(statesel).unbind('click');
        if (!e.wasClean) {
          window.setTimeout(init, 5000);
        }
      };
      conn.onclose = again;
      conn.onerror = again;
      conn.onmessage = onmessage;
      $(statesel).click(function() {
        history.pushState({
          path: this.path
        }, '', this.href);
        sendSearch(this.search);
        return false;
      });
    };
    init();
    return {
      sendClient: sendClient,
      sendSearch: sendSearch,
      close: function() {
        return conn.close();
      },
      getconn: function() {
        return conn;
      }
    };
  };

  this.HideClass = React.createClass({
    reduce: function(data) {
      var value;
      if ((data != null) && (data.Client != null)) {
        value = data.Client[this.props.key];
        if (value !== void 0) {
          return {
            Hide: value
          };
        }
      }
    },
    getInitialState: function() {
      return this.reduce(Data);
    },
    componentDidMount: function() {
      return this.props.$click_el.click(this.click);
    },
    render: function() {
      this.props.$collapse_el.collapse(this.state.Hide ? 'hide' : 'show');
      return React.DOM.span(null, null);
    },
    click: function(e) {
      var S;
      (S = {})[this.props.key] = !this.state.Hide;
      websocket.sendClient(S);
      e.stopPropagation();
      e.preventDefault();
      return void 0;
    }
  });

  this.ShowSwapClass = React.createClass({
    getInitialState: function() {
      return ShowSwapClass.reduce(Data);
    },
    statics: {
      reduce: function(data) {
        var S;
        if ((data != null) && (data.Client != null)) {
          S = {};
          if (data.Client.HideSWAP !== void 0) {
            S.HideSWAP = data.Client.HideSWAP;
          }
          if (data.Client.HideMEM !== void 0) {
            S.HideMEM = data.Client.HideMEM;
          }
          return S;
        }
      }
    },
    componentDidMount: function() {
      return this.props.$el.click(this.click);
    },
    render: function() {
      this.props.$el[!this.state.HideSWAP ? 'addClass' : 'removeClass']('active');
      return React.DOM.span(null, this.props.$el.text());
    },
    click: function(e) {
      var S;
      S = {
        HideSWAP: !this.state.HideSWAP
      };
      if (this.state.HideMEM) {
        S.HideMEM = false;
      }
      websocket.sendClient(S);
      e.stopPropagation();
      e.preventDefault();
      return void 0;
    }
  });

}).call(this);
