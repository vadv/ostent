// generated by jsonenums -type=UintDF; DO NOT EDIT

package client

import (
	"encoding/json"
	"fmt"
)

var (
	_UintDFNameToValue = map[string]UintDF{
		"FS":    FS,
		"MP":    MP,
		"TOTAL": TOTAL,
		"USED":  USED,
		"AVAIL": AVAIL,
	}

	_UintDFValueToName = map[UintDF]string{
		FS:    "FS",
		MP:    "MP",
		TOTAL: "TOTAL",
		USED:  "USED",
		AVAIL: "AVAIL",
	}
)

func init() {
	var v UintDF
	if _, ok := interface{}(v).(fmt.Stringer); ok {
		_UintDFNameToValue = map[string]UintDF{
			interface{}(FS).(fmt.Stringer).String():    FS,
			interface{}(MP).(fmt.Stringer).String():    MP,
			interface{}(TOTAL).(fmt.Stringer).String(): TOTAL,
			interface{}(USED).(fmt.Stringer).String():  USED,
			interface{}(AVAIL).(fmt.Stringer).String(): AVAIL,
		}
	}
}

func (r UintDF) MarshalJSON() ([]byte, error) {
	if s, ok := interface{}(r).(fmt.Stringer); ok {
		return json.Marshal(s.String())
	}
	s, ok := _UintDFValueToName[r]
	if !ok {
		return nil, fmt.Errorf("invalid UintDF: %d", r)
	}
	return json.Marshal(s)
}

func (r *UintDF) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("UintDF should be a string, got %s", data)
	}
	v, ok := _UintDFNameToValue[s]
	if !ok {
		return fmt.Errorf("invalid UintDF %q", s)
	}
	*r = v
	return nil
}
